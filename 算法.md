# 链表

虚拟头结点：使代码更简单，不用单独考虑空链表的情况

## 快慢指针（同向而行）

- 节点定位：倒数第n个节点、链表中点
- 判断是否成环
- 原地修改数组（链表）

# 数组

## 左右指针

- 相向而行：二分查找（有序）
- 反向而行：最长回文串

# 二叉堆

应用：堆排序、优先级队列

最大堆：**每个节点都大于等于它的两个子节点**

可以使用数组来实现，下标0不存储数据，主要操作时下沉和上浮

## 二叉树

### 思想

思路

- 遍历一遍二叉树得出答案
- 通过分解问题计算出答案

1. **遍历**

以递归方式实现

- 前序位置：**刚进入一个节点（元素）的时候** ---- 自顶向下
- 后序位置：**即将离开一个节点（元素）的时候** ---- 自底向上

```java
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    // 前序位置
    traverse(head.next);
    // 后序位置
}
```

2. **分解**

分而治之的思想：将树需要解决的问题转换为子树需要解决的问题



遇到一道二叉树的题目时的通用思考过程是：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

**3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。

## 二叉搜索树

二叉搜索树是左小右大，可以利用这一特性，采用中序遍历的方式，将节点的值`升序`排列（或`降序`排列）

# 图

## 搜索

### BFS

常搭配Queue使用，一般不需要使用递归，使用poll()和offer()两个函数，将符合条件入队，遍历完的出队，直到队列为空

### DFS

常使用递归实现

## 拓扑排序算法

将图中的节点进行排序，将节点看成活动，边表示活动间的先后关系，排序后的结果是：**在每个活动开始时，能够保证它的前驱活动都已完成**

只有**有向无环图**才能进行拓扑排序

可以使用dfs或bfs辅助进行排序

## 二分图的判定

可以用二着色的思想，能被二着色的图一定是二分图
