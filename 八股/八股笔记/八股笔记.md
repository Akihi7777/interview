# JVM

## 堆内存分配

### 指针碰撞

一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是 指针碰撞。

<img src="八股笔记.assets/image-20240411210811730.png" alt="image-20240411210811730" style="zoom: 67%;" />

### 空闲列表

如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞啦，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。

### TLAB

## 垃圾回收器

### 类型

#### 新生代收集器

- Serial收集器：复制算法，单线程收集器，标记和清理都是单线程，优点是简单高效
- ParNew收集器：复制算法，并行收集器，实际上是Serial收集器的多线程版
- Parallel Scavenge收集器：复制算法，并行收集器，追求高吞吐量，高效利用 CPU

#### 老年代收集器

- Serial Old收集器：复制算法，单线程收集器
- Parallel Old收集器 ：标记-整理算法，并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本
- CMS(Concurrent Mark Sweep)收集器：标记-清除算法，并行收集器，以获取**最短回收停顿时间**为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间

#### 整堆收集器

- G1(Garbage First)收集器：标记-整理算法，不会产生内存碎片，回收的范围是**整个Java堆**

### 如何选择

# 多线程和并发

## 线程的使用

### 创建线程

严格来说，Java 就只有一种方式可以创建线程，那就是通过`new Thread().start()`创建。

### 实现多线程的方法

1. 继承Thread类

   ```java
   public class ExtendsThread extends Thread {
       @Override
       public void run() {
           System.out.println("1......");
       }
   
       public static void main(String[] args) {
           new ExtendsThread().start();
       }
   }
   ```

   

2. 实现Runnable接口

3. 实现Callable接口

4. 线程池方式创建

5. 使用`CompletableFuture`类

## 线程安全

### 多线程的问题

内存泄漏、死锁、线程不安全等
