# 手写一个rpc

## rpc总体框架

### 架构图

简略版：

<img src="C:\Users\汪思敏\AppData\Roaming\Typora\typora-user-images\image-20240328160620485.png" alt="image-20240328160620485" style="zoom:67%;" />

详细版：

<img src="C:\Users\汪思敏\AppData\Roaming\Typora\typora-user-images\image-20240328160033563.png" alt="image-20240328160033563" style="zoom: 80%;" />

服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server

实现一个最基本的 RPC 框架应该至少包括下面几部分:

1. **注册中心** ：注册中心负责服务地址的注册与查找，相当于目录服务。
2. **网络传输** ：既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。
3. **序列化和反序列化** ：要在网络传输数据就要涉及到**序列化**。
4. **动态代理** ：屏蔽远程方法调用的底层细节。
5. **负载均衡** ： 避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题。
6. **传输协议** ：这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。

## 实现

### 注册中心

注册中心负责服务**地址的注册与查找**，相当于目录服务。本项目使用zookeeper作为注册中心，常用的还有Nacos和Redis。

ZooKeeper 通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。并且，ZooKeeper 将数据保存在`内存`中，性能是非常棒的。 在`“读”多于“写”`的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。

### 网络传输

网络传输即**发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端**，本项目使用Netty做网络传输，常用的还有Socket和NIO。

#### **Socket 网络通信**

##### 什么是Socket

Socket 是一个抽象概念，应用程序可以通过它发送或接收数据。套接字是 IP 地址与端口的组合：
$$
 Socket=（IP 地址：端口号）
$$
在 Java 开发中使用 Socket 时会常用到两个类，都在 `java.net` 包中：

1. `Socket`：一般用于客户端
2. `ServerSocket` ：用于服务端

##### Socket 网络通信过程

- Socket 网络通信过程简单来说分为下面 4 步：

1. 建立服务端并且监听客户端请求
2. 客户端请求，服务端和客户端建立连接
3. 两端之间可以传递数据
4. 关闭资源

Socket 网络通信过程如下图所示：

<img src="C:\Users\汪思敏\AppData\Roaming\Typora\typora-user-images\image-20240329150944811.png" alt="image-20240329150944811" style="zoom:67%;" />

- 对应到服务端和客户端的话，是下面这样的。

**服务器端：**

1. 创建 `ServerSocket` 对象并且绑定地址（ip）和端口号(port)：`server.bind(new InetSocketAddress(host, port))`
2. 通过 `accept()`方法监听客户端请求
3. 连接建立后，通过输入流读取客户端发送的请求信息
4. 通过输出流向客户端发送响应信息
5. 关闭相关资源

**客户端：**

1. 创建`Socket` 对象并且连接指定的服务器的地址（ip）和端口号(port)：`socket.connect(inetSocketAddress)`
2. 连接建立后，通过输出流向服务器端发送请求信息
3. 通过输入流获取服务器响应的信息
4. 关闭相关资源

##### 局限

1. `ServerSocket` 的 accept（） 方法是**阻塞方法**，也就是说 `ServerSocket` 在调用 accept（） 等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。
2. 只能同时处理一个客户端的连接，如果需要管理多个客户端的话，就需要为我们请求的客户端单独创建一个线程。每次使用都创建线程会造成资源浪费，可以使用**线程池**，创建和回收的成本较低，并且可以指定最大线程数量。

#### Netty

介绍：

1. **Netty 是一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。**
2. 它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。
3. 支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议

使用场景：

- 作为 RPC 框架的网络通信工具
- 实现一个自己的 HTTP 服务器 
- 实现一个即时通讯系统
- 消息推送系统



`.handler()`方法用于设置一些针对于整个Channel的处理器，这些处理器通常在Channel的生命周期中只需要设置一次。因此，Netty提供了两个方法用于设置处理器，分别是`.handler()`和`.childHandler()`。其中，`.handler()`方法设置的处理器是针对ServerBootstrap所创建的ServerChannel的，而`.childHandler()`方法设置的处理器是针对ServerBootstrap所接受的连接的Channel的。



### 序列化和反序列化

**为什么需要序列化和反序列化呢？** 
因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其**序列化**为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次**反序列化**。

<img src="C:\Users\汪思敏\AppData\Roaming\Typora\typora-user-images\image-20240328161302687.png" alt="image-20240328161302687" style="zoom:80%;" />

现在比较常用序列化的有 hessian、**kryo**、protostuff，JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差

#### Java自带序列化方式

JDK 自带的序列化，只需实现 `java.io.Serializable`接口即可。

1. **serialVersionUID 有什么作用？**

序列化号 `serialVersionUID` 属于版本控制的作用。反序列化时，会检查 `serialVersionUID` 是否和当前类的 `serialVersionUID` 一致。

2. **serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？**

static修饰的变量是静态变量，位于方法区，本身是不会被序列化的。static变量是属于类的而不是对象。反序列之后，static变量的值就像是默认赋予给了对象一样，看着就像是static变量被序列化，实际只是假象罢了。

3. **有些字段不想进行序列化怎么办？**

使用 `transient` 关键字修饰。

- transient 只能修饰 `变量`，不能修饰类和方法。
- transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰int 类型，那么反序列后结果就是0。
- static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。

4. **为什么不推荐使用 JDK 自带的序列化？**

- **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
- **性能差** ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
- **存在安全问题** ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。

#### Kryo

Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。

1.  Kryo 不是线程安全的，所以使用 `ThreadLocal` 来确保每个线程都有自己的 `Kryo` 实例
2. 使用kryo.writeObject(output, obj) 和kryo.readObject(input, clazz) 分别实现序列化和反序列化
3. Output 或 Input 对象在退出 try 块后会自动关闭，而在关闭之前，需要将 Kryo 实例从 ThreadLocal 中移除（kryoThreadLocal.remove()），防止内存泄漏

